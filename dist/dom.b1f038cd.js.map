{"version":3,"sources":["dom.js"],"names":["window","dom","create","elementString","template","document","createElement","innerHTML","content","firstChild","append","parentNode","node","appendChild","before","sibling","insertBefore","after","nextSibling","wrap","wrapNode","wrappedNode","remove","removeChild","empty","child","result","push","attr","name","value","arguments","length","setAttribute","getAttribute","text","innerText","contenText","style","Object","key","class","add","className","classList","has","contains","on","eventName","fn","addEventListener","off","removeEventListener","find","selector","scope","querySelectorAll","parent","children","siblings","Array","from","filter","n","next","x","nodeType","previous","previousSibling","each","nodeList","i","call","index","list"],"mappings":"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","file":"dom.b1f038cd.js","sourceRoot":"..\\src","sourcesContent":["window.dom = {\r\n\tcreate(elementString) {\r\n\t\tconst template = document.createElement('template')\r\n\t\ttemplate.innerHTML = elementString\r\n\t\t// 我们将新节点创建在template下面\r\n\t\t// 然后将创建在template下面的节点append到要被添加的节点后面\r\n\t\t// append的特性是移除原节点下的内容，并将这些节点内容放到新节点下。\r\n\t\t// 而我们创建在template下的节点是在其content.firstChild内。\r\n\t\treturn template.content.firstChild\r\n\t},\r\n\t// 添加为子节点\r\n\tappend(parentNode, node) {\r\n\t\tparentNode.appendChild(node)\r\n\t},\r\n\t// 添加到节点的前面\r\n\tbefore(sibling, node) {\r\n\t\tsibling.parentNode.insertBefore(node, sibling)\r\n\t},\r\n\t// 添加到节点的后面\r\n\tafter(sibling, node) {\r\n\t\tsibling.parentNode.insertBefore(node, sibling.nextSibling)\r\n\t},\r\n\t// 将一个节点包裹住另一个节点，即给一个节点创建一个父亲\r\n\twrap(wrapNode, wrappedNode) {\r\n\t\tthis.before(wrappedNode, wrapNode)\r\n\t\tthis.append(wrapNode, wrappedNode)\r\n\t},\r\n\r\n\t// 删除操作\r\n\tremove(node) {\r\n\t\treturn node.parentNode.removeChild(node)\r\n\t},\r\n\t// 清空一个节点下的所有节点\r\n\tempty(node) {\r\n\t\tlet child = node.firstChild\r\n\t\tlet result = []\r\n\t\twhile (child) {\r\n\t\t\t// 由于 = 操作符是一个浅拷贝，所以这里不能使用child来删除，只能用作判断，\r\n\t\t\t// 因为找不到parent，只能用node.firsChild\r\n\t\t\tresult.push(this.remove(node.firstChild))\r\n\t\t\tchild = node.firstChild\r\n\t\t}\r\n\t\treturn result\r\n\t},\r\n\t// 设置属性和获取属性\r\n\tattr(node, name, value) {\r\n\t\tif (arguments.length === 3) {\r\n\t\t\tnode.setAttribute(name, value)\r\n\t\t} else if (arguments.length === 2) {\r\n\t\t\treturn node.getAttribute(name)\r\n\t\t}\r\n\t},\r\n\t// 设置节点文本内容，1 个参数是获取，2 个参数是设置\r\n\ttext(node, value) {\r\n\t\tif (arguments.length === 2) {\r\n\t\t\tif ('innerText' in node) {\r\n\t\t\t\tnode.innerText = value\r\n\t\t\t} else {\r\n\t\t\t\tnode.contenText = value\r\n\t\t\t}\r\n\t\t} else if (arguments.length == 1) {\r\n\t\t\treturn 'innerText' in node ? node.innerText : node.contenText\r\n\t\t}\r\n\t},\r\n\t// 设置样式：\r\n\t// 1 个参数是返回节点的style，\r\n\t// 2 个参数时，是字符串就返回样式，是对象则以键值对的方式设置样式。\r\n\t// 3 个参数是设置某个特定的样式，比如设置color\r\n\tstyle(node, name, value) {\r\n\t\tif (arguments.length === 3) {\r\n\t\t\tnode.style[name] = value\r\n\t\t} else if (arguments.length === 2) {\r\n\t\t\tif (typeof name === 'string') {\r\n\t\t\t\treturn node.style[name]\r\n\t\t\t} else if (name instanceof Object) {\r\n\t\t\t\tfor (key in name) {\r\n\t\t\t\t\tnode.style[key] = name[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t// 设置、取消、查询类样式\r\n\tclass: {\r\n\t\tadd(node, className) {\r\n\t\t\tnode.classList.add(className)\r\n\t\t},\r\n\t\tremove(node, className) {\r\n\t\t\tnode.classList.remove(className)\r\n\t\t},\r\n\t\thas(node, className) {\r\n\t\t\treturn node.classList.contains(className)\r\n\t\t},\r\n\t},\r\n\t// 设置、取消监听函数\r\n\ton(node, eventName, fn) {\r\n\t\tnode.addEventListener(eventName, fn)\r\n\t},\r\n\toff(node, eventName, fn) {\r\n\t\tnode.removeEventListener(eventName, fn)\r\n\t},\r\n\t// 查找元素，有查找范围就在范围内找，没有就从document内找。\r\n\tfind(selector, scope) {\r\n\t\treturn (scope || document).querySelectorAll(selector)\r\n\t},\r\n\tparent(node) {\r\n\t\treturn node.parentNode\r\n\t},\r\n\tchildren(node) {\r\n\t\treturn node.children\r\n\t},\r\n\t// 找到所有兄弟节点\r\n\tsiblings(node) {\r\n\t\treturn Array.from(node.parentNode.children).filter((n) => n !== node)\r\n\t},\r\n\tnext(node) {\r\n\t\tlet x = node.nextSibling\r\n\t\twhile (x && x.nodeType === 3) {\r\n\t\t\tx = x.nextSibling\r\n\t\t}\r\n\t\treturn x\r\n\t},\r\n\tprevious(node) {\r\n\t\tlet x = node.previousSibling\r\n\t\twhile (x && x.nodeType === 3) {\r\n\t\t\tx = x.previousSibling\r\n\t\t}\r\n\t\treturn x\r\n\t},\r\n\t// 遍历节点下的所有元素\r\n\teach(nodeList, fn) {\r\n\t\tfor (let i = 0; i < nodeList.length; i++) {\r\n\t\t\tfn.call(null, nodeList[i])\r\n\t\t}\r\n\t},\r\n\t// 获取当前节点的下标\r\n\tindex(node) {\r\n\t\tconst list = this.children(node.parentNode)\r\n\t\tlet i\r\n\t\tfor (i = 0; i < list.length; i++) {\r\n\t\t\tif (list[i] === node) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn i\r\n\t},\r\n}\r\n"]}